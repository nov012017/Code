#!/usr/bin/env python

# Copyright (C) 2006-2013  Open Data ("Open Data" refers to
# one or more of the following companies: Open Data Partners LLC,
# Open Data Research LLC, or Open Data Capital LLC.)
#
# This file is part of Augustus.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""This module defines the PlotWindow class."""

import math
import json

from augustus.core.defs import defs
from augustus.core.SvgBinding import SvgBinding
from augustus.core.plot.PmmlPlotFrame import PmmlPlotFrame
from augustus.core.plot.PlotStyle import PlotStyle
from augustus.core.plot.PmmlPlotContent import PmmlPlotContent
from augustus.core.plot.PlotContentBox import PlotContentBox
from augustus.core.plot.PlotCoordinatesOffset import PlotCoordinatesOffset
from augustus.core.plot.PlotCoordinatesWindow import PlotCoordinatesWindow
from augustus.core.plot.PlotRange import PlotRange
from augustus.core.plot.PlotTickMarks import PlotTickMarks
from augustus.core.plot.PmmlPlotContentAnnotation import PmmlPlotContentAnnotation
from augustus.pmml.plot.PlotOverlay import PlotOverlay

class PlotWindow(PmmlPlotFrame):
    """PlotWindow represents a plot with four borders, tick marks, and
    optional axis labels on each.
    
    It uses a CSS margin, border, and padding to define the plot area,
    which means that axis labels extend into the margins and ticks
    extend into the padding, unlike most uses of the
    U{CSS box model<http://www.w3.org/TR/CSS2/box.html>}.
    The default left and bottom margins are large enough to accomodate
    these graphics.

    PMML subelements:

      - PlotOverlays: each of which is a separate coordinate system.
        Usually, you will only want one PlotOverlay with many plot
        elements in it.  The value of having multiple PlotOverlays is
        that it allows for different coordinate systems described by
        different axes, such as a histogram (PDF) and its accumulation
        (CDF), with the left axis measuring the histogram and the right
        axis measuring the accumulation.
      - Any PLOT-CONTENT-ANNOTAION (PmmlPlotContentAnnotation), which
        is not bound to any in-plot coordinate system.

    Overlays and annotations can appear in any order.

    PMML attributes:

      - svgId: id for the resulting SVG element.
      - xlabel: text below the x axis.
      - ylabel: text to the left of the y axis.
      - toplabel: text above the top axis.
      - rightlabel: text to the right of the right axis.
      - colorlabel: text along the color (z) axis (generated by heat maps).
      - xticks-source: 1-based index of the PlotOverlays element to use
        to set the x axis ticks.
      - yticks-source, topticks-source, rightticks-source: same for
        each of the other axes.  This is how one configures a plot with
        two different axes.
      - colorticks-source: same for the color (z) axis.
      - xticks: format specification for the x axis ticks, see PlotTickMarks.
      - yticks, rightticks, topticks: same for the other axes.
      - colorticks: same for the color (z) axis.
      - xticks-draw: one of "nothing", "ticks-only", "parallel-labels",
        "perpendicular-labels": how much of the x axis ticks to draw.
        The "ticks-only" option draws unlabled lines; the "parallel" and
        "perpendicular" options draw text labels that are either aligned
        with or perpendicular to the axis.
      - yticks-draw, topticks-draw, rightticks-draw: same for the other
        axes.
      - colorticks-draw: same for the color (z) ticks.
      - style: CSS style properties.

    CSS properties:

      - margin-top, margin-right, margin-bottom, margin-left,
        margin-colorright, margin: space between the enclosure and the
        border of the plot window, which is very thick on the
        left and bottom to accomodate the tick labels and axis
        labels, which are outside the border.
      - border-top-width, border-right-width, border-bottom-width,
        border-left-width, border-width: thickness of the border.
      - padding-top, padding-right, padding-bottom, padding-left,
        padding: space between the border and the inner content.
      - background, background-opacity: color of the background
        of the plot window.
      - border-color, border-dasharray, border-dashoffset,
        border-linecap, border-linejoin, border-miterlimit,
        border-opacity, border-width: properties of the border line.
      - font, font-family, font-size, font-size-adjust, font-stretch,
        font-style, font-variant, font-weight: font properties for
        the tick labels and axis labels.
      - label-color, xlabel-color, ylabel-color, toplabel-color,
        rightlabel-color, colorlabel-color: label color.
      - ticklabel-color, xticklabel-color, yticklabel-color, topticklabel-color,
        rightticklabel-color, colorticklabel-color: ticklabel color.
      - tick-color, xtick-color, ytick-color, toptick-color,
        righttick-color, colortick-color: tick color.
      - tick-length, xtick-length, ytick-length, toptick-length
        righttick-length, colortick-length: tick length.
      - minitick-length, xminitick-length, yminitick-length,
        topminitick-length, rightminitick-length,
        colorminitick-length: minitick length.
      - xtick-label-xoffset, xtick-label-yoffset, ytick-label-xoffset,
        ytick-label-yoffset, toptick-label-xoffset,
        toptick-label-yoffset, righttick-label-xoffset,
        righttick-label-yoffset, colortick-label-xoffset,
        colortick-label-yoffset: tick label offset.
      - label-margin, xlabel-margin, ylabel-margin, toplabel-margin,
        rightlabel-margin, colorlabel-margin: axis label margin.
      - colorscale-width: width of the colorscale bar.

    See the source code for the full XSD.
    """

    class _State(object):
        pass

    styleProperties = ["margin-top", "margin-right", "margin-bottom", "margin-left", "margin-colorright", "margin",
                       "border-top-width", "border-right-width", "border-bottom-width", "border-left-width", "border-width",
                       "padding-top", "padding-right", "padding-bottom", "padding-left", "padding",
                       "background", "background-opacity", 
                       "border-color", "border-dasharray", "border-dashoffset", "border-linecap", "border-linejoin", "border-miterlimit", "border-opacity", "border-width",
                       "font", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight",
                       "label-color", "xlabel-color", "ylabel-color", "toplabel-color", "rightlabel-color", "colorlabel-color",
                       "ticklabel-color", "xticklabel-color", "yticklabel-color", "topticklabel-color", "rightticklabel-color", "colorticklabel-color",
                       "tick-color", "xtick-color", "ytick-color", "toptick-color", "righttick-color", "colortick-color",
                       "tick-length", "xtick-length", "ytick-length", "toptick-length", "righttick-length", "colortick-length",
                       "minitick-length", "xminitick-length", "yminitick-length", "topminitick-length", "rightminitick-length", "colorminitick-length",
                       "xtick-label-xoffset", "xtick-label-yoffset", "ytick-label-xoffset", "ytick-label-yoffset", "toptick-label-xoffset", "toptick-label-yoffset", "righttick-label-xoffset", "righttick-label-yoffset", "colortick-label-xoffset", "colortick-label-yoffset",
                       "label-margin", "xlabel-margin", "ylabel-margin", "toplabel-margin", "rightlabel-margin", "colorlabel-margin",
                       "colorscale-width"
                       ]

    styleDefaults = {"background": "none", "border-color": "black", "margin": "10", "margin-bottom": "60", "margin-left": "100", "margin-right": "50", "margin-colorright": "50", "padding": "0", "border-width": "2", "font-size": "25.0",
                     "label-color": "black", "ticklabel-color": "black", "tick-color": "black",
                     "tick-length": "20.0", "minitick-length": "10.0",
                     "xtick-label-xoffset": "0.0", "xtick-label-yoffset": "15.0",
                     "ytick-label-xoffset": "-15.0", "ytick-label-yoffset": "0.0",
                     "toptick-label-xoffset": "0.0", "toptick-label-yoffset": "-15.0",
                     "righttick-label-xoffset": "15.0", "righttick-label-yoffset": "0.0",
                     "colortick-label-xoffset": "10.0", "colortick-label-yoffset": "0.0",
                     "label-margin": "17.0",
                     "colorscale-width": "75"
                     }

    xsd = """<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:element name="PlotWindow">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="Extension" minOccurs="0" maxOccurs="unbounded" />
                <xs:choice minOccurs="0" maxOccurs="unbounded">
                    <xs:element ref="PlotOverlay" minOccurs="1" maxOccurs="1" />
                    <xs:group ref="PLOT-CONTENT-ANNOTATION" minOccurs="1" maxOccurs="1" />
                </xs:choice>
                <xs:sequence minOccurs="0" maxOccurs="1">
                    <xs:element ref="PlotGradientStop" minOccurs="2" maxOccurs="unbounded" />
                </xs:sequence>
            </xs:sequence>
            <xs:attribute name="svgId" type="xs:string" use="optional" />
            <xs:attribute name="xlabel" type="xs:string" use="optional" />
            <xs:attribute name="ylabel" type="xs:string" use="optional" />
            <xs:attribute name="toplabel" type="xs:string" use="optional" />
            <xs:attribute name="rightlabel" type="xs:string" use="optional" />
            <xs:attribute name="colorlabel" type="xs:string" use="optional" />
            <xs:attribute name="xticks-source" type="INT-NUMBER" use="optional" default="1" />
            <xs:attribute name="yticks-source" type="INT-NUMBER" use="optional" default="1" />
            <xs:attribute name="topticks-source" type="INT-NUMBER" use="optional" default="1" />
            <xs:attribute name="rightticks-source" type="INT-NUMBER" use="optional" default="1" />
            <xs:attribute name="colorticks-source" type="INT-NUMBER" use="optional" default="1" />
            <xs:attribute name="xticks" type="xs:string" use="optional" default="auto" />
            <xs:attribute name="yticks" type="xs:string" use="optional" default="auto" />
            <xs:attribute name="topticks" type="xs:string" use="optional" default="auto" />
            <xs:attribute name="rightticks" type="xs:string" use="optional" default="auto" />
            <xs:attribute name="colorticks" type="xs:string" use="optional" default="auto" />
            <xs:attribute name="xticks-draw" type="PLOT-TICKS-DRAW" use="optional" default="parallel-labels" />
            <xs:attribute name="yticks-draw" type="PLOT-TICKS-DRAW" use="optional" default="perpendicular-labels" />
            <xs:attribute name="topticks-draw" type="PLOT-TICKS-DRAW" use="optional" default="ticks-only" />
            <xs:attribute name="rightticks-draw" type="PLOT-TICKS-DRAW" use="optional" default="ticks-only" />
            <xs:attribute name="colorticks-draw" type="PLOT-TICKS-DRAW" use="optional" default="perpendicular-labels" />
            <xs:attribute name="style" type="xs:string" use="optional" default="%s" />
        </xs:complexType>
    </xs:element>
</xs:schema>
""" % PlotStyle.toString(styleDefaults)

    xsdRemove = ["PLOT-TICKS-DRAW", "UNIT-INTERVAL", "PlotGradientStop"]

    xsdAppend = ["""<xs:simpleType name="PLOT-TICKS-DRAW" xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:restriction base="xs:string">
        <xs:enumeration value="nothing" />
        <xs:enumeration value="ticks-only" />
        <xs:enumeration value="parallel-labels" />
        <xs:enumeration value="perpendicular-labels" />
    </xs:restriction>
</xs:simpleType>
""",
                 """<xs:simpleType name="UNIT-INTERVAL" xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:restriction base="xs:decimal">
        <xs:minInclusive value="0" />
        <xs:maxInclusive value="1" />
    </xs:restriction>
</xs:simpleType>
""",
                 """<xs:element name="PlotGradientStop" xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:complexType>
        <xs:attribute name="offset" type="UNIT-INTERVAL" use="required" />
        <xs:attribute name="red" type="UNIT-INTERVAL" use="required" />
        <xs:attribute name="green" type="UNIT-INTERVAL" use="required" />
        <xs:attribute name="blue" type="UNIT-INTERVAL" use="required" />
        <xs:attribute name="opacity" type="UNIT-INTERVAL" use="optional" default="1" />
    </xs:complexType>
</xs:element>
"""]

    def frame(self, dataTable, functionTable, performanceTable, plotCoordinates, plotContentBox, plotDefinitions):
        """Draw a plot frame and the plot elements it contains.

        @type dataTable: DataTable
        @param dataTable: Contains the data to plot.
        @type functionTable: FunctionTable
        @param functionTable: Defines functions that may be used to transform data for plotting.
        @type performanceTable: PerformanceTable
        @param performanceTable: Measures and records performance (time and memory consumption) of the drawing process.
        @type plotCoordinates: PlotCoordinates
        @param plotCoordinates: The coordinate system in which this plot will be placed (not the coordinate system defined by the plot).
        @type plotContentBox: PlotContentBox
        @param plotContentBox: A bounding box in which this plot will be placed.
        @type plotDefinitions: PlotDefinitions
        @type plotDefinitions: The dictionary of key-value pairs that forms the <defs> section of the SVG document.
        @rtype: SvgBinding
        @return: An SVG fragment representing the fully drawn plot.
        """

        svg = SvgBinding.elementMaker
        performanceTable.begin("PlotWindow")

        svgId = self.get("svgId")
        content = []
        if svgId is None: attrib = {}
        else: attrib = {"id": svgId}

        style = self.getStyleState()
        subContentBox = plotContentBox.subContent(style)
        borderRect = plotContentBox.border(style)

        adjustForColorScale = []

        ### draw the background

        if borderRect is not None:
            rectStyle = {"fill": style["background"], "stroke": "none"}
            if "background-opacity" in style:
                rectStyle["fill-opacity"] = style["background-opacity"]

            x1 = borderRect.x
            y1 = borderRect.y
            x2 = borderRect.x + borderRect.width
            y2 = borderRect.y + borderRect.height
            x1, y1 = plotCoordinates(x1, y1)
            x2, y2 = plotCoordinates(x2, y2)

            subAttrib = {"x": repr(x1), "y": repr(y1), "width": repr(x2 - x1), "height": repr(y2 - y1), "style": PlotStyle.toString(rectStyle)}
            if svgId is not None:
                subAttrib["id"] = svgId + ".background"
            if rectStyle["fill"] != "none":
                r = svg.rect(**subAttrib)
                content.append(r)
                adjustForColorScale.append(r)

        sawAnnotation = False
        aboveTicks = []
        if subContentBox is not None:
            ### create a clipping region for the contents

            if svgId is None:
                svgIdClip = plotDefinitions.uniqueName()
            else:
                svgIdClip = svgId + ".clip"

            r = svg.rect(x=repr(x1), y=repr(y1), width=repr(x2 - x1), height=repr(y2 - y1))
            clipPath = svg.clipPath(r, id=svgIdClip)
            plotDefinitions[svgIdClip] = clipPath
            adjustForColorScale.append(r)

            x1 = subContentBox.x
            y1 = subContentBox.y
            x2 = subContentBox.x + subContentBox.width
            y2 = subContentBox.y + subContentBox.height
            x1, y1 = plotCoordinates(x1, y1)
            x2, y2 = plotCoordinates(x2, y2)

            clippedDataAttrib = {"clip-path": "url(#%s)" % svgIdClip}

            ### handle the contents

            xticksSourceIndex = self.get("xticks-source", defaultFromXsd=True, convertType=True)
            yticksSourceIndex = self.get("yticks-source", defaultFromXsd=True, convertType=True)
            topticksSourceIndex = self.get("topticks-source", defaultFromXsd=True, convertType=True)
            rightticksSourceIndex = self.get("rightticks-source", defaultFromXsd=True, convertType=True)
            colorticksSourceIndex = self.get("colorticks-source", defaultFromXsd=True, convertType=True)
            xticksSource = None
            yticksSource = None
            topticksSource = None
            rightticksSource = None
            colorticksSource = None

            states = {}
            for coordinatesIndex, overlay in enumerate(self.childrenOfClass(PlotOverlay)):
                plotContents = overlay.childrenOfClass(PmmlPlotContent)

                xlog = overlay.get("xlog", defaultFromXsd=True, convertType=True)
                ylog = overlay.get("ylog", defaultFromXsd=True, convertType=True)
                zlog = overlay.get("zlog", defaultFromXsd=True, convertType=True)
                plotRange = PlotRange(xStrictlyPositive=xlog, yStrictlyPositive=ylog, zStrictlyPositive=zlog)

                ### calculate the contents' coordinates to determine ranges
                performanceTable.pause("PlotWindow")
                for plotContent in plotContents:
                    states[plotContent] = self._State()
                    plotContent.prepare(states[plotContent], dataTable, functionTable, performanceTable, plotRange)
                performanceTable.unpause("PlotWindow")

                xmin, ymin, xmax, ymax = plotRange.ranges()
                xmin = float(overlay.get("xmin", xmin))
                ymin = float(overlay.get("ymin", ymin))
                xmax = float(overlay.get("xmax", xmax))
                ymax = float(overlay.get("ymax", ymax))

                zmin, zmax = plotRange.zranges()

                if zmin is None or zmax is None:
                    zmin = None
                    zmax = None
                else:
                    zmin = float(overlay.get("zmin", zmin))
                    zmax = float(overlay.get("zmax", zmax))

                ### create the inner coordinate system
                plotCoordinatesWindow = PlotCoordinatesWindow(plotCoordinates, xmin, ymin, xmax, ymax, subContentBox.x, subContentBox.y, subContentBox.width, subContentBox.height, flipy=True, xlog=xlog, ylog=ylog, xfieldType=plotRange.xfieldType, yfieldType=plotRange.yfieldType, xstrings=plotRange.xstrings, ystrings=plotRange.ystrings)

                if coordinatesIndex + 1 == xticksSourceIndex:
                    xticksSource = plotCoordinatesWindow
                if coordinatesIndex + 1 == yticksSourceIndex:
                    yticksSource = plotCoordinatesWindow
                if coordinatesIndex + 1 == topticksSourceIndex:
                    topticksSource = plotCoordinatesWindow
                if coordinatesIndex + 1 == rightticksSourceIndex:
                    rightticksSource = plotCoordinatesWindow
                if coordinatesIndex + 1 == colorticksSourceIndex:
                    colorticksSource = (zmin, zmax, zlog, plotRange.zfieldType)

                for plotContent in plotContents:
                    states[plotContent].plotCoordinatesWindow = plotCoordinatesWindow

            ### figure out if you have any color ticks, since the color tick box shifts the contents
            if colorticksSource is None or zmin is None or zmax is None:
                colorticksSource = None
                colorticksDraw = "nothing"
                colorticks, colorminiticks = None, None
            else:
                zmin, zmax, zlog, cfieldType = colorticksSource

                if zmin is None or zmax is None:
                    colorticksDraw = "nothing"
                    colorticks, colorminiticks = None, None
                else:
                    colorticksDraw = self.get("colorticks-draw", defaultFromXsd=True)
                    tickSpecification = self.get("colorticks", defaultFromXsd=True)

                    if tickSpecification == "auto":
                        if cfieldType.istemporal():
                            colorticks, colorminiticks = PlotTickMarks.interpret("time()", zmin, zmax)
                        elif zlog:
                            colorticks, colorminiticks = PlotTickMarks.interpret("log(~10)", zmin, zmax)
                        else:
                            colorticks, colorminiticks = PlotTickMarks.interpret("linear(~10)", zmin, zmax)
                    elif tickSpecification == "none":
                        colorticks, colorminiticks = {}, []
                    else:
                        colorticks, colorminiticks = PlotTickMarks.interpret(tickSpecification, zmin, zmax)

            gradient = self.childrenOfTag("PlotGradientStop")
            lastStop = None
            for plotGradientStop in gradient:
                offset = float(plotGradientStop["offset"])
                if lastStop is not None and offset <= lastStop:
                    raise defs.PmmlValidationError("Sequence of PlotGradientStop must be strictly increasing in \"offset\"")
                lastStop = offset

            xshiftForColorScale = 0.0
            if colorticksDraw != "nothing":
                xshiftForColorScale += float(style["colorscale-width"]) + float(style["colortick-label-xoffset"]) + float(style["margin-colorright"])
                if self["colorlabel"] is not None:
                    xshiftForColorScale += float(style.get("colorlabel-margin", style["label-margin"]))

            if colorticksSource is not None:
                colorticksSource = PlotCoordinatesWindow(plotCoordinates, 0.0, zmin, 1.0, zmax, subContentBox.x + subContentBox.width - xshiftForColorScale, subContentBox.y, xshiftForColorScale, subContentBox.height, flipy=True, xlog=False, ylog=zlog, xfieldType=cfieldType, yfieldType=cfieldType, xstrings=[], ystrings=[])

                cx2 = plotCoordinates(borderRect.x + borderRect.width, borderRect.y)[0] - float(style["margin-colorright"])
                if self["colorlabel"] is not None:
                    cx2 -= float(style.get("colorlabel-margin", style["label-margin"]))

            for r in adjustForColorScale:
                r["width"] = repr(float(r["width"]) - xshiftForColorScale)

            subContentBox.width -= xshiftForColorScale
            borderRect.width -= xshiftForColorScale

            done = set()
            if xticksSource is not None:
                xticksSource.outerX2 -= xshiftForColorScale
                done.add(xticksSource)
            if yticksSource is not None and yticksSource not in done:
                yticksSource.outerX2 -= xshiftForColorScale
                done.add(yticksSource)
            if topticksSource is not None and topticksSource not in done:
                topticksSource.outerX2 -= xshiftForColorScale
                done.add(topticksSource)
            if rightticksSource is not None and rightticksSource not in done:
                rightticksSource.outerX2 -= xshiftForColorScale
                done.add(rightticksSource)

            ### actually draw the contents and the non-coordinate annotations
            annotationCoordinates = PlotCoordinatesOffset(plotCoordinates, subContentBox.x, subContentBox.y)
            annotationBox = PlotContentBox(0, 0, subContentBox.width, subContentBox.height)

            for overlayOrAnnotation in self.getchildren():
                performanceTable.pause("PlotWindow")

                whatToDraw = []
                if isinstance(overlayOrAnnotation, PlotOverlay):
                    plotContents = overlayOrAnnotation.childrenOfClass(PmmlPlotContent)
                    for plotContent in plotContents:
                        plotCoordinatesWindow = states[plotContent].plotCoordinatesWindow
                        if zmin is not None and zmax is not None:
                            plotCoordinatesWindow.zmin = zmin
                            plotCoordinatesWindow.zmax = zmax
                            plotCoordinatesWindow.zlog = zlog
                            plotCoordinatesWindow.gradient = gradient

                        whatToDraw.append(svg.g(plotContent.draw(states[plotContent], plotCoordinatesWindow, plotDefinitions, performanceTable), **clippedDataAttrib))

                elif isinstance(overlayOrAnnotation, PmmlPlotContentAnnotation):
                    whatToDraw.append(overlayOrAnnotation.draw(dataTable, functionTable, performanceTable, annotationCoordinates, annotationBox, plotDefinitions))
                    sawAnnotation = True

                if sawAnnotation:
                    aboveTicks.extend(whatToDraw)
                else:
                    content.extend(whatToDraw)

                performanceTable.unpause("PlotWindow")

            del states

        if borderRect is not None:
            rectStyle = {"stroke": style["border-color"]}

            for styleProperty in "border-dasharray", "border-dashoffset", "border-linecap", "border-linejoin", "border-miterlimit", "border-opacity", "border-width":
                if styleProperty in style:
                    rectStyle[styleProperty.replace("border-", "stroke-")] = style[styleProperty]

            x1 = borderRect.x
            y1 = borderRect.y
            x2 = borderRect.x + borderRect.width
            y2 = borderRect.y + borderRect.height
            x1, y1 = plotCoordinates(x1, y1)
            x2, y2 = plotCoordinates(x2, y2)

            subAttrib = {"x": repr(x1), "y": repr(y1), "width": repr(x2 - x1), "height": repr(y2 - y1), "style": PlotStyle.toString(rectStyle)}
            if svgId is not None:
                subAttrib["id"] = svgId + ".border"

            ### draw the tick-marks and axis labels

            leftEdge, topEdge = plotCoordinates(plotContentBox.x, plotContentBox.y)
            rightEdge, bottomEdge = plotCoordinates(plotContentBox.x + plotContentBox.width, plotContentBox.y + plotContentBox.height)

            performanceTable.begin("tickmarks")

            if xticksSource is None:
                xticks = {}
                xminiticks = []
            else:
                tickSpecification = self.get("xticks", defaultFromXsd=True)
                if tickSpecification == "auto":
                    if xticksSource.xfieldType.isstring():
                        xticks, xminiticks = PlotTickMarks.interpret("explicit({%s})" % ", ".join("%d: \"%s\"" % (i, x) for i, x in enumerate(xticksSource.xstrings)), xticksSource.innerX1, xticksSource.innerX2)
                    elif xticksSource.xfieldType.istemporal():
                        xticks, xminiticks = PlotTickMarks.interpret("time()", xticksSource.innerX1, xticksSource.innerX2)
                    elif xticksSource.xlog:
                        xticks, xminiticks = PlotTickMarks.interpret("log(~10)", xticksSource.innerX1, xticksSource.innerX2)
                    else:
                        xticks, xminiticks = PlotTickMarks.interpret("linear(~10)", xticksSource.innerX1, xticksSource.innerX2)
                elif tickSpecification == "none":
                    xticks, xminiticks = {}, []
                else:
                    xticks, xminiticks = PlotTickMarks.interpret(tickSpecification, xticksSource.innerX1, xticksSource.innerX2)

            if yticksSource is None:
                yticks = {}
                yminiticks = []
            else:
                tickSpecification = self.get("yticks", defaultFromXsd=True)
                if tickSpecification == "auto":
                    if yticksSource.yfieldType.isstring():
                        yticks, yminiticks = PlotTickMarks.interpret("explicit({%s})" % ", ".join("%d: \"%s\"" % (i, x) for i, x in enumerate(yticksSource.ystrings)), yticksSource.innerY1, yticksSource.innerY2)
                    elif yticksSource.yfieldType.istemporal():
                        yticks, yminiticks = PlotTickMarks.interpret("time()", yticksSource.innerY1, yticksSource.innerY2)
                    elif yticksSource.ylog:
                        yticks, yminiticks = PlotTickMarks.interpret("log(~10)", yticksSource.innerY1, yticksSource.innerY2)
                    else:
                        yticks, yminiticks = PlotTickMarks.interpret("linear(~10)", yticksSource.innerY1, yticksSource.innerY2)
                elif tickSpecification == "none":
                    yticks, yminiticks = {}, []
                else:
                    yticks, yminiticks = PlotTickMarks.interpret(tickSpecification, yticksSource.innerY1, yticksSource.innerY2)

            if topticksSource is None:
                topticks = {}
                topminiticks = []
            else:
                tickSpecification = self.get("topticks", defaultFromXsd=True)
                if tickSpecification == "auto" and topticksSource == xticksSource:
                    topticks, topminiticks = xticks, xminiticks

                elif tickSpecification == "auto":
                    if topticksSource.xfieldType.isstring():
                        topticks, topminiticks = PlotTickMarks.interpret("explicit({%s})" % ", ".join("%d: \"%s\"" % (i, x) for i, x in enumerate(topticksSource.xstrings)), topticksSource.innerX1, topticksSource.innerX2)
                    elif topticksSource.xfieldType.istemporal():
                        topticks, topminiticks = PlotTickMarks.interpret("time()", topticksSource.innerX1, topticksSource.innerX2)
                    elif topticksSource.xlog:
                        topticks, topminiticks = PlotTickMarks.interpret("log(~10)", topticksSource.innerX1, topticksSource.innerX2)
                    else:
                        topticks, topminiticks = PlotTickMarks.interpret("linear(~10)", topticksSource.innerX1, topticksSource.innerX2)
                    

                elif tickSpecification == "none":
                    topticks, topminiticks = {}, []

                else:
                    topticks, topminiticks = PlotTickMarks.interpret(tickSpecification, topticksSource.innerX1, topticksSource.innerX2)

            if rightticksSource is None:
                rightticks = {}
                rightminiticks = []
            else:
                tickSpecification = self.get("rightticks", defaultFromXsd=True)
                if tickSpecification == "auto" and rightticksSource == yticksSource:
                    rightticks, rightminiticks = yticks, yminiticks

                elif tickSpecification == "auto":
                    if rightticksSource.yfieldType.isstring():
                        rightticks, rightminiticks = PlotTickMarks.interpret("explicit({%s})" % ", ".join("%d: \"%s\"" % (i, x) for i, x in enumerate(rightticksSource.ystrings)), rightticksSource.innerY1, rightticksSource.innerY2)
                    elif rightticksSource.yfieldType.istemporal():
                        rightticks, rightminiticks = PlotTickMarks.interpret("time()", rightticksSource.innerY1, rightticksSource.innerY2)
                    elif rightticksSource.ylog:
                        rightticks, rightminiticks = PlotTickMarks.interpret("log(~10)", rightticksSource.innerY1, rightticksSource.innerY2)
                    else:
                        rightticks, rightminiticks = PlotTickMarks.interpret("linear(~10)", rightticksSource.innerY1, rightticksSource.innerY2)

                elif tickSpecification == "none":
                    rightticks, rightminiticks = {}, []

                else:
                    rightticks, rightminiticks = PlotTickMarks.interpret(tickSpecification, rightticksSource.innerY1, rightticksSource.innerY2)

            textStyle = {"stroke": "none"}
            for styleProperty in "font", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight":
                if styleProperty in style:
                    textStyle[styleProperty] = style[styleProperty]

            # very few SVG renderers do dominant-baseline: middle, alignment-baseline: middle, baseline-shift: middle, etc., so we have to emulate it
            dyMiddle = repr(0.35*float(style["font-size"]))

            # x (bottom) ticks
            xticksDraw = self.get("xticks-draw", defaultFromXsd=True)
            if xticksSource is not None and xticksDraw in ("ticks-only", "parallel-labels", "perpendicular-labels"):
                if svgId is None:
                    xticksGroup = svg.g()
                else:
                    xticksGroup = svg.g(id=(svgId + ".xticks"))

                xticklabelColor = style.get("xticklabel-color", style["ticklabel-color"])
                xtickColor = style.get("xtick-color", style["tick-color"])
                xtickLength = float(style.get("xtick-length", style["tick-length"]))
                xminitickLength = float(style.get("xminitick-length", style["minitick-length"]))

                eps = defs.EPSILON * (rightEdge - leftEdge)
                transformedTicks = dict((xticksSource(x, 1.0)[0], label) for x, label in xticks.items())
                transformedMiniticks = [xticksSource(x, 1.0)[0] for x in xminiticks if x not in xticks]
                xticksGroup.append(svg.path(d=" ".join("M %r,%r L %r,%r" % (x, y2, x, y2 - xminitickLength) for x in transformedMiniticks if x1 + eps < x < x2 - eps), style=("stroke: %s; fill: none" % xtickColor)))
                xticksGroup.append(svg.path(d=" ".join("M %r,%r L %r,%r" % (x, y2, x, y2 - xtickLength) for x in transformedTicks if x1 + eps < x < x2 - eps), style="stroke: %s; fill: none" % xtickColor))

                if xticksDraw in ("parallel-labels", "perpendicular-labels"):
                    xoffset, yoffset = float(style["xtick-label-xoffset"]), float(style["xtick-label-yoffset"])
                    textStyle["fill"] = xticklabelColor

                    for x, label in transformedTicks.items():
                        if x1 - eps < x < x2 + eps:
                            labelAttributes = {"font-size": style["font-size"], defs.XML_SPACE: "preserve", "dy": dyMiddle, "style": PlotStyle.toString(textStyle)}
                            if xticksDraw == "parallel-labels":
                                labelAttributes["transform"] = "translate(%r,%r)" % (x + xoffset, y2 + yoffset)
                                labelAttributes["text-anchor"] = "middle"
                            elif xticksDraw == "perpendicular-labels":
                                labelAttributes["transform"] = "translate(%r,%r) rotate(-90)" % (x + xoffset, y2 + yoffset)
                                labelAttributes["text-anchor"] = "end"
                            xticksGroup.append(svg.text(label, **labelAttributes))

                content.append(xticksGroup)

            # x (bottom) label
            xlabel = self.get("xlabel", "")
            if xlabel != "":
                labelMargin = float(style.get("xlabel-margin", style["label-margin"]))
                textStyle["fill"] = style.get("xlabel-color", style["label-color"])
                labelAttributes = {"transform": "translate(%r,%r)" % ((x1 + x2)/2.0, bottomEdge - labelMargin), "text-anchor": "middle", defs.XML_SPACE: "preserve", "dy": dyMiddle, "font-size": style["font-size"], "style": PlotStyle.toString(textStyle)}
                content.append(svg.text(xlabel, **labelAttributes))

            # y (left) ticks
            yticksDraw = self.get("yticks-draw", defaultFromXsd=True)
            if yticksSource is not None and yticksDraw in ("ticks-only", "parallel-labels", "perpendicular-labels"):
                if svgId is None:
                    yticksGroup = svg.g()
                else:
                    yticksGroup = svg.g(id=(svgId + ".yticks"))

                yticklabelColor = style.get("yticklabel-color", style["ticklabel-color"])
                ytickColor = style.get("ytick-color", style["tick-color"])
                ytickLength = float(style.get("ytick-length", style["tick-length"]))
                yminitickLength = float(style.get("yminitick-length", style["minitick-length"]))

                eps = defs.EPSILON * (bottomEdge - topEdge)
                transformedTicks = dict((yticksSource(1.0, y)[1], label) for y, label in yticks.items())
                transformedMiniticks = [yticksSource(1.0, y)[1] for y in yminiticks if y not in yticks]
                yticksGroup.append(svg.path(d=" ".join("M %r,%r L %r,%r" % (x1, y, x1 + yminitickLength, y) for y in transformedMiniticks if y1 + eps < y < y2 - eps), style=("stroke: %s; fill: none" % ytickColor)))
                yticksGroup.append(svg.path(d=" ".join("M %r,%r L %r,%r" % (x1, y, x1 + ytickLength, y) for y in transformedTicks if y1 + eps < y < y2 - eps), style="stroke: %s; fill: none" % ytickColor))

                if yticksDraw in ("parallel-labels", "perpendicular-labels"):
                    xoffset, yoffset = float(style["ytick-label-xoffset"]), float(style["ytick-label-yoffset"])
                    textStyle["fill"] = yticklabelColor

                    for y, label in transformedTicks.items():
                        if y1 - eps < y < y2 + eps:
                            labelAttributes = {"font-size": style["font-size"], defs.XML_SPACE: "preserve", "dy": dyMiddle, "style": PlotStyle.toString(textStyle)}
                            if yticksDraw == "parallel-labels":
                                labelAttributes["transform"] = "translate(%r,%r) rotate(-90)" % (x1 + xoffset, y + yoffset)
                                labelAttributes["text-anchor"] = "middle"
                            elif yticksDraw == "perpendicular-labels":
                                labelAttributes["transform"] = "translate(%r,%r)" % (x1 + xoffset, y + yoffset)
                                labelAttributes["text-anchor"] = "end"
                            yticksGroup.append(svg.text(label, **labelAttributes))

                content.append(yticksGroup)

            # y (left) label
            ylabel = self.get("ylabel", "")
            if ylabel != "":
                labelMargin = float(style.get("ylabel-margin", style["label-margin"]))
                textStyle["fill"] = style.get("ylabel-color", style["label-color"])
                labelAttributes = {"transform": "translate(%r,%r) rotate(-90)" % (leftEdge + labelMargin, (y1 + y2)/2.0), "text-anchor": "middle", defs.XML_SPACE: "preserve", "dy": dyMiddle, "font-size": style["font-size"], "style": PlotStyle.toString(textStyle)}
                content.append(svg.text(ylabel, **labelAttributes))

            # top ticks
            topticksDraw = self.get("topticks-draw", defaultFromXsd=True)
            if topticksSource is not None and topticksDraw in ("ticks-only", "parallel-labels", "perpendicular-labels"):
                if svgId is None:
                    topticksGroup = svg.g()
                else:
                    topticksGroup = svg.g(id=(svgId + ".topticks"))

                topticklabelColor = style.get("topticklabel-color", style["ticklabel-color"])
                toptickColor = style.get("toptick-color", style["tick-color"])
                toptickLength = float(style.get("toptick-length", style["tick-length"]))
                topminitickLength = float(style.get("topminitick-length", style["minitick-length"]))

                eps = defs.EPSILON * (rightEdge - leftEdge)
                transformedTicks = dict((topticksSource(x, 1.0)[0], label) for x, label in topticks.items())
                transformedMiniticks = [topticksSource(x, 1.0)[0] for x in topminiticks if x not in topticks]
                topticksGroup.append(svg.path(d=" ".join("M %r,%r L %r,%r" % (x, y1, x, y1 + topminitickLength) for x in transformedMiniticks if x1 + eps < x < x2 - eps), style=("stroke: %s; fill: none" % toptickColor)))
                topticksGroup.append(svg.path(d=" ".join("M %r,%r L %r,%r" % (x, y1, x, y1 + toptickLength) for x in transformedTicks if x1 + eps < x < x2 - eps), style="stroke: %s; fill: none" % toptickColor))

                if topticksDraw in ("parallel-labels", "perpendicular-labels"):
                    xoffset, yoffset = float(style["toptick-label-xoffset"]), float(style["toptick-label-yoffset"])
                    textStyle["fill"] = topticklabelColor

                    for x, label in transformedTicks.items():
                        if x1 - eps < x < x2 + eps:
                            labelAttributes = {"font-size": style["font-size"], defs.XML_SPACE: "preserve", "dy": dyMiddle, "style": PlotStyle.toString(textStyle)}
                            if topticksDraw == "parallel-labels":
                                labelAttributes["transform"] = "translate(%r,%r)" % (x + xoffset, y1 + yoffset)
                                labelAttributes["text-anchor"] = "middle"
                            elif topticksDraw == "perpendicular-labels":
                                labelAttributes["transform"] = "translate(%r,%r) rotate(-90)" % (x + xoffset, y1 + yoffset)
                                labelAttributes["text-anchor"] = "start"
                            topticksGroup.append(svg.text(label, **labelAttributes))

                content.append(topticksGroup)

            # top label
            toplabel = self.get("toplabel", "")
            if toplabel != "":
                labelMargin = float(style.get("toplabel-margin", style["label-margin"]))
                textStyle["fill"] = style.get("toplabel-color", style["label-color"])
                labelAttributes = {"transform": "translate(%r,%r)" % ((x1 + x2)/2.0, topEdge + labelMargin), "text-anchor": "middle", defs.XML_SPACE: "preserve", "dy": dyMiddle, "font-size": style["font-size"], "style": PlotStyle.toString(textStyle)}
                content.append(svg.text(toplabel, **labelAttributes))

            # right ticks
            rightticksDraw = self.get("rightticks-draw", defaultFromXsd=True)
            if rightticksSource is not None and rightticksDraw in ("ticks-only", "parallel-labels", "perpendicular-labels"):
                if svgId is None:
                    rightticksGroup = svg.g()
                else:
                    rightticksGroup = svg.g(id=(svgId + ".rightticks"))

                rightticklabelColor = style.get("rightticklabel-color", style["ticklabel-color"])
                righttickColor = style.get("righttick-color", style["tick-color"])
                righttickLength = float(style.get("righttick-length", style["tick-length"]))
                rightminitickLength = float(style.get("rightminitick-length", style["minitick-length"]))

                eps = defs.EPSILON * (bottomEdge - topEdge)
                transformedTicks = dict((rightticksSource(1.0, y)[1], label) for y, label in rightticks.items())
                transformedMiniticks = [rightticksSource(1.0, y)[1] for y in rightminiticks if y not in rightticks]
                rightticksGroup.append(svg.path(d=" ".join("M %r,%r L %r,%r" % (x2, y, x2 - rightminitickLength, y) for y in transformedMiniticks if y1 + eps < y < y2 - eps), style=("stroke: %s; fill: none" % righttickColor)))
                rightticksGroup.append(svg.path(d=" ".join("M %r,%r L %r,%r" % (x2, y, x2 - righttickLength, y) for y in transformedTicks if y1 + eps < y < y2 - eps), style="stroke: %s; fill: none" % righttickColor))

                if rightticksDraw in ("parallel-labels", "perpendicular-labels"):
                    xoffset, yoffset = float(style["righttick-label-xoffset"]), float(style["righttick-label-yoffset"])
                    textStyle["fill"] = rightticklabelColor

                    for y, label in transformedTicks.items():
                        if y1 - eps < y < y2 + eps:
                            labelAttributes = {"font-size": style["font-size"], defs.XML_SPACE: "preserve", "dy": dyMiddle, "style": PlotStyle.toString(textStyle)}
                            if rightticksDraw == "parallel-labels":
                                labelAttributes["transform"] = "translate(%r,%r) rotate(90)" % (x2 + xoffset, y + yoffset)
                                labelAttributes["text-anchor"] = "middle"
                            elif rightticksDraw == "perpendicular-labels":
                                labelAttributes["transform"] = "translate(%r,%r)" % (x2 + xoffset, y + yoffset)
                                labelAttributes["text-anchor"] = "start"
                            rightticksGroup.append(svg.text(label, **labelAttributes))

                content.append(rightticksGroup)

            # right label
            rightlabel = self.get("rightlabel", "")
            if rightlabel != "":
                labelMargin = float(style.get("rightlabel-margin", style["label-margin"]))
                textStyle["fill"] = style.get("rightlabel-color", style["label-color"])
                labelAttributes = {"transform": "translate(%r,%r) rotate(90)" % (rightEdge - labelMargin, (y1 + y2)/2.0), "text-anchor": "middle", defs.XML_SPACE: "preserve", "dy": dyMiddle, "font-size": style["font-size"], "style": PlotStyle.toString(textStyle)}
                content.append(svg.text(rightlabel, **labelAttributes))

            # color ticks
            if colorticksSource is not None and colorticksDraw in ("ticks-only", "parallel-labels", "perpendicular-labels"):
                if svgId is None:
                    colorticksGroup = svg.g()
                else:
                    colorticksGroup = svg.g(id=(svgId + ".colorticks"))

                if len(gradient) == 0:
                    linearGradient = svg.linearGradient(id=plotDefinitions.uniqueName(), x1="0%", y1="100%", x2="0%", y2="0%")
                    linearGradient.append(svg.stop(offset="0%", style="stop-color:rgb(255,255,255); stop-opacity: 1.0;"))
                    linearGradient.append(svg.stop(offset="100%", style="stop-color:rgb(0,0,255); stop-opacity: 1.0;"))
                else:
                    linearGradient = svg.linearGradient(id=plotDefinitions.uniqueName(), x1="0%", y1="100%", x2="0%", y2="0%")
                    for stop in gradient:
                        offset = "%r%%" % (100.0 * float(stop["offset"]))
                        gradientStyle = "stop-color:rgb(%r,%r,%r);" % (min(int(math.floor(256.0 * float(stop["red"]))), 255), min(int(math.floor(256.0 * float(stop["green"]))), 255), min(int(math.floor(256.0 * float(stop["blue"]))), 255))
                        opacity = stop.get("opacity")
                        if opacity is not None:
                            gradientStyle += " stop-opacity: %s;" % opacity
                        linearGradient.append(svg.stop(offset=offset, style=gradientStyle))

                plotDefinitions[linearGradient["id"]] = linearGradient

                gradientStyle = rectStyle.copy()
                gradientStyle["fill"] = "url(#%s)" % linearGradient["id"]
                colorticksGroup.append(svg.rect(**{"x": repr(cx2 - float(style["colorscale-width"])), "y": repr(y1), "width": style["colorscale-width"], "height": repr(y2 - y1), "style": PlotStyle.toString(gradientStyle)}))

                colorticklabelColor = style.get("colorticklabel-color", style["ticklabel-color"])
                colortickColor = style.get("colortick-color", style["tick-color"])
                colortickLength = float(style.get("colortick-length", style["tick-length"]))
                colorminitickLength = float(style.get("colorminitick-length", style["minitick-length"]))

                eps = defs.EPSILON * (bottomEdge - topEdge)
                transformedTicks = dict((colorticksSource(1.0, y)[1], label) for y, label in colorticks.items())
                transformedMiniticks = [colorticksSource(1.0, y)[1] for y in colorminiticks if y not in colorticks]
                colorticksGroup.append(svg.path(d=" ".join("M %r,%r L %r,%r" % (cx2, y, cx2 - colorminitickLength, y) for y in transformedMiniticks if y1 + eps < y < y2 - eps), style=("stroke: %s; fill: none" % colortickColor)))
                colorticksGroup.append(svg.path(d=" ".join("M %r,%r L %r,%r" % (cx2, y, cx2 - colortickLength, y) for y in transformedTicks if y1 + eps < y < y2 - eps), style="stroke: %s; fill: none" % colortickColor))

                if colorticksDraw in ("parallel-labels", "perpendicular-labels"):
                    xoffset, yoffset = float(style["colortick-label-xoffset"]), float(style["colortick-label-yoffset"])
                    textStyle["fill"] = colorticklabelColor

                    for y, label in transformedTicks.items():
                        if y1 - eps < y < y2 + eps:
                            labelAttributes = {"font-size": style["font-size"], defs.XML_SPACE: "preserve", "dy": dyMiddle, "style": PlotStyle.toString(textStyle)}
                            if colorticksDraw == "parallel-labels":
                                labelAttributes["transform"] = "translate(%r,%r) rotate(90)" % (cx2 + xoffset, y + yoffset)
                                labelAttributes["text-anchor"] = "middle"
                            elif colorticksDraw == "perpendicular-labels":
                                labelAttributes["transform"] = "translate(%r,%r)" % (cx2 + xoffset, y + yoffset)
                                labelAttributes["text-anchor"] = "start"
                            colorticksGroup.append(svg.text(label, **labelAttributes))

                content.append(colorticksGroup)

            # color label
            colorlabel = self.get("colorlabel", "")
            if colorlabel != "":
                labelMargin = float(style.get("colorlabel-margin", style["label-margin"]))
                textStyle["fill"] = style.get("colorlabel-color", style["label-color"])
                labelAttributes = {"transform": "translate(%r,%r) rotate(90)" % (rightEdge - labelMargin, (y1 + y2)/2.0), "text-anchor": "middle", defs.XML_SPACE: "preserve", "dy": dyMiddle, "font-size": style["font-size"], "style": PlotStyle.toString(textStyle)}
                content.append(svg.text(colorlabel, **labelAttributes))

            performanceTable.end("tickmarks")

            ### draw the bounding box

            if rectStyle["stroke"] != "none":
                content.append(svg.rect(**subAttrib))

        content.extend(aboveTicks)

        performanceTable.end("PlotWindow")
        return svg.g(*content, **attrib)
